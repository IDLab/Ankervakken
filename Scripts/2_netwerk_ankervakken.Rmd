---
title: "2_netwerk_ankervakken"
output: html_document
---

``` {r load_packages}
library (ggplot2)
library (graph)
library (network)
library (dplyr)
library (GGally)
library (plotly)
library (reshape2)

```
### Voorkomen van kortste afstanden (altijd <300m)
overzicht van voorkomen van kortste afstanden bij schepenparen

```{r hist_dist}
load ("../Data/1_reading_cleaning/min_afstand_tijd.Rda")

ggplot(data = min_afstand_tijd, aes(x=d_min*1852)) +
  geom_histogram(binwidth = 10, colour = "#FF6666", fill = "#FF6666", alpha = "0.5") +
  xlab("Kortste afstand (in meter") +
  ylab("Aantal")

```
### Tijdsduur van contact
overzicht van welke tijdsduur schepen binnen 'bandbreedte' van afstand bij elkaar in de buurt zijn

```{r hist_time}
ggplot(data = subset(min_afstand_tijd, delta_t >0), aes(x=delta_t/3600)) +
  geom_histogram(binwidth = 0.1, colour = "#FF6666", fill = "#FF6666", alpha = "0.5") +
  xlab("contact tijd (in uren)") +
  ylab("Aantal paren")

```
### Tijdsduur van contact vs afstand
overzicht van welke tijdsduur schepen binnen 'bandbreedte' van afstand bij elkaar in de buurt zijn

```{r time_dist}
ggplot(data = subset(min_afstand_tijd, delta_t >0), aes(x=delta_t/3600, y = d_min*1852)) +
  geom_point(colour = "#FF6666", fill = "#FF6666", alpha = "0.5") +
  xlab("contact tijd (in uren") +
  ylab("kortste onderlinge afstand")

```

### Heatmap scheepstypen

```{r}

# Heatmap
S1_Vessel.Type<- c(min_afstand_tijd$S1_Vessel.Type, min_afstand_tijd$S2_Vessel.Type)
S2_Vessel.Type <- c(min_afstand_tijd$S2_Vessel.Type, min_afstand_tijd$S1_Vessel.Type)
data <- as.data.frame(cbind(S1_Vessel.Type, S2_Vessel.Type))


matrix_voor_heatmap <-
  data %>%
  filter(!(S1_Vessel.Type %in% c("Data not found", "webpage not found", "NA"))) %>%
  filter(!(S2_Vessel.Type %in% c("Data not found", "webpage not found", "NA")))
matrix_voor_heatmap <-
  matrix_voor_heatmap %>%
  dcast(S1_Vessel.Type ~ S2_Vessel.Type, fun.aggregate = length, drop = FALSE)
matrix_voor_heatmap[is.na(matrix_voor_heatmap)] <- 0
hm_input <- as.matrix(matrix_voor_heatmap[,2:length(names(matrix_voor_heatmap))])

 plot_ly(x = colnames(hm_input) , y = colnames(hm_input) , z = hm_input, type = "heatmap")
plot_ly(z = hm_input, type = "heatmap")
```

```{r}

# Heatmap
S1_Length<- c(min_afstand_tijd$S1_Length, min_afstand_tijd$S2_Length)
S2_Length <- c(min_afstand_tijd$S2_Length, min_afstand_tijd$S1_Length)
data <- as.data.frame(cbind(S1_Length, S2_Length))


matrix_voor_heatmap <-
  data %>%
  filter(!(S1_Length %in% c("Data not found", "webpage not found", "NA"))) %>%
  filter(!(S2_Length %in% c("Data not found", "webpage not found", "NA")))
matrix_voor_heatmap <-
  matrix_voor_heatmap %>%
  dcast(S1_Length ~ S2_Length, fun.aggregate = length, drop = FALSE)
matrix_voor_heatmap[is.na(matrix_voor_heatmap)] <- 0
hm_input <- as.matrix(matrix_voor_heatmap[,2:length(names(matrix_voor_heatmap))])

 plot_ly( z = hm_input, type = "heatmap")

```

### Netwerk onderlinge afstand schepen
Let op: dikte lijn en NIET lengte representeert afstand (verwarrend...)

```{r plot_network}
# Edge list
data_netwerk <-
  min_afstand_tijd %>%
  select(MMSI1, MMSI2, d_min) %>%
  filter(d_min != 0)%>%
  arrange(d_min)

# Van edge list naar adjacency matrix
adj_matrix <- ftM2adjM(as.matrix(data_netwerk[,1:2]), W=data_netwerk$d_min)

# Netwerkje maken
netwerk_input <- network(adj_matrix, directed=FALSE)

# Edge size bepalen
edgesize <- mean(data_netwerk$d_min) / data_netwerk$d_min
edgesize <- (data_netwerk$d_min/(300/1852))*2

# Netwerk visualiseren
ggnet2(
  netwerk_input,
  node.color = "blue",
  node.size = 5,
  edge.size = edgesize,
  edge.color = "lightblue",
  label = TRUE,
  label.size = 1
)

```


